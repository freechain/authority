// Generated by LiveScript 1.5.0
(function(){
  var ref$, find, each, pairsToObj, map, span, even, capitalize, transaction, web3, verifyNetwork, errorPage, planGetRace, getRace, restoreRace, noMetamaskAccount, restoreProfile, fillBet, restoreBet, restoreSale, restorePage, simpleRoute, raceRoute, profileRoute, saleRoute, betRoute, finishRoute, config, updateRouter, restoreItem, goto, reload, onHrefClick, restoreRouter, out$ = typeof exports != 'undefined' && exports || this, toString$ = {}.toString;
  ref$ = require('prelude-ls'), find = ref$.find, each = ref$.each, pairsToObj = ref$.pairsToObj, map = ref$.map, span = ref$.span, even = ref$.even, capitalize = ref$.capitalize;
  transaction = require('mobx').transaction;
  web3 = require('../eth.ls');
  verifyNetwork = require('./verify-network.ls');
  errorPage = function(err, store){
    if (err === "Default Account Is Not Found") {
      return noMetamaskAccount(store);
    }
    store.current.page = 'error';
    return store.current.error = err;
  };
  planGetRace = function(raceId, store, cb){
    var repeatGetRace;
    repeatGetRace = function(){
      return getRace(raceId, store, cb);
    };
    return setTimeout(repeatGetRace, 100);
  };
  getRace = function(raceId, store, cb){
    var race, lap, requestRace, this$ = this;
    race = find(function(it){
      return it.id === raceId;
    })(
    store.races);
    if (race == null) {
      returcb(cb("Race Not Found"));
    }
    if (+race.lap === -1) {
      return planGetRace(raceId, store, cb);
    }
    if (+race.lap === +store.current.lap) {
      return cb(null, race);
    }
    lap = store.current.lap;
    requestRace = {
      lap: lap,
      raceEthAddress: race.raceEthAddress,
      id: race.id,
      name: race.name
    };
    return raceFromContract(requestRace, function(err, contractRace){
      if (err != null) {
        return cb(err);
      }
      contractRace.fromContract = true;
      if (contractRace.cars.length === 0) {
        return cb("Cars Not Found in Contract");
      }
      return cb(null, contractRace);
    });
  };
  restoreRace = function(url, store, cb){
    var ref$, _, raceId, lap, car;
    ref$ = url.split('/'), _ = ref$[0], _ = ref$[1], raceId = ref$[2], lap = ref$[3], car = ref$[4];
    delete store.current.race;
    if (+lap < 0) {
      return cb("There are no started races");
    }
    store.current.car = car;
    store.current.lap = lap;
    return getRace(raceId, store, function(err, race){
      if (err != null) {
        return cb(err);
      }
      if (+lap !== +race.lap) {
        return cb("Expected lap " + lap + ", Given: " + race.lap);
      }
      if (race == null) {
        return cb("Race Not Found", store);
      }
      store.current.race = race;
      setupCountdown(store);
      myTokenBalance(function(err, me){
        if (err != null) {
          return cb(err);
        }
        importAll$(store.me, me);
        return myBets(store.current, function(err, data){
          importAll$(store.current, data);
          if (err != null) {
            return cb(err);
          }
          return cb(null);
        });
      });
    });
  };
  noMetamaskAccount = function(store){
    return store.current.bet.page = 'metamask';
  };
  restoreProfile = function(url, store, cb){
    var defaultAccount;
    defaultAccount = web3.eth.defaultAccount;
    store.current.account = defaultAccount;
    return cb(null);
  };
  fillBet = function(store, cb){
    var defaultAccount;
    defaultAccount = web3.eth.defaultAccount;
    if (defaultAccount == null) {
      return noMetamaskAccount(store);
    }
    return web3.eth.getBalance(defaultAccount, function(err, res){
      var contract;
      if (err != null) {
        return cb(err);
      }
      store.current.account = defaultAccount;
      store.current.bet.balanceWei = res.toString();
      store.current.bet.balance = web3.fromWei(res, 'ether');
      contract = getContract.token;
      if (err != null) {
        return cb(err);
      }
      contract.balanceOf(defaultAccount, function(err, res){
        var balance;
        balance = res;
        if (err != null) {
          return cb(err);
        }
        store.current.bet.balanceTokens18 = balance.toString();
        store.current.bet.balanceTokens = web3.fromWei(balance, 'ether');
        store.current.bet.sendTokens = store.current.bet.balanceTokens;
        store.current.bet.page = balance.eq(0) ? 'hasno' : 'has';
        cb(null);
      });
    });
  };
  restoreBet = function(url, store, cb){
    return verifyNetwork(function(err){
      if (err != null) {
        return cb(err);
      }
      return restoreRace(url, store, function(err){
        if (err != null) {
          return cb(err);
        }
        if (store.current.car == null) {
          return cb("Car is not Defined");
        }
        store.current.bet.page = 'checking';
        fillBet(store, function(err){
          if (err != null) {
            return cb(err);
          }
          cb(null);
        });
      });
    });
  };
  restoreSale = function(url, store, cb){
    return verifyNetwork(function(err){
      if (err != null) {
        return cb(err);
      }
      store.current.bet.page = 'checking';
      return myTokenBalance(function(err, me){
        if (err != null) {
          return cb(err);
        }
        importAll$(store.me, me);
        return fillBet(store, function(err){
          if (err != null) {
            return cb(err);
          }
          store.current.bet.page = 'hasno';
          cb(null);
        });
      });
    });
  };
  restorePage = function(url, store, cb){
    var defaultAccount;
    defaultAccount = web3.eth.defaultAccount;
    return myTokenBalance(function(err, me){
      if (err != null) {
        return cb(err);
      }
      importAll$(store.me, me);
      return cb(null);
    });
  };
  simpleRoute = function(page){
    return {
      url: function(store){
        return "/" + page;
      },
      restore: restorePage
    };
  };
  raceRoute = {
    url: function(store){
      return "/race/" + store.current.race.id + "/" + store.current.lap;
    },
    restore: restoreRace,
    title: function(store){
      return "Race - " + store.current.race.name;
    }
  };
  profileRoute = {
    url: function(store){
      return '/profile';
    },
    restore: restoreProfile,
    title: function(store){
      return "Your profile";
    }
  };
  saleRoute = {
    url: function(store){
      return '/sale';
    },
    restore: restoreSale,
    title: function(store){
      return "Tokensale";
    }
  };
  betRoute = {
    url: function(store){
      return "/bet/" + store.current.race.id + "/" + store.current.lap + "/" + store.current.car;
    },
    restore: restoreBet,
    title: function(store){
      return "Bet - " + store.current.car.toUpperCase() + " - " + store.current.race.name;
    }
  };
  finishRoute = {
    url: function(store){
      return "/finish/" + store.current.race.id + "/" + store.current.lap;
    },
    restore: restoreRace,
    title: function(store){
      return "Finished - " + store.current.race.name;
    }
  };
  out$.config = config = {
    'choose': '/',
    'landing': '/landing',
    'research': '/research',
    'history': simpleRoute('history'),
    'currencyrates': simpleRoute('currencyrates'),
    'terms': simpleRoute('terms'),
    'whitepaper': simpleRoute('whitepaper'),
    'rules': simpleRoute('rules'),
    'sale': saleRoute,
    'bet': betRoute,
    'finish': finishRoute,
    'profile': profileRoute,
    'race': raceRoute
  };
  updateRouter = function(store){
    var title, type, page, ref$;
    title = store.current.page;
    type = config[store.current.page];
    page = (function(){
      switch (false) {
      case toString$.call(type).slice(8, -1) !== 'Object':
        return type.url(store);
      default:
        return type;
      }
    }());
    if (((ref$ = history.state) != null ? ref$.page : void 8) === page) {
      return;
    }
    history.pushState({
      page: page
    }, title, page);
    return window.scrollTo(0, 0);
  };
  restoreItem = function(url, item, store, cb){
    if (item == null) {
      return cb("Reuter is not resolved");
    }
    if (toString$.call(item).slice(8, -1) !== 'Object') {
      return cb(null);
    }
    if (toString$.call(item.restore).slice(8, -1) !== 'Function') {
      return cb("Restore Router Function is Not Defined for " + item.url);
    }
    return item.restore(url, store, function(err){
      if (err != null) {
        return cb(err);
      }
      cb(null);
    });
  };
  out$.goto = goto = function(url, store){
    var page, item;
    page = function(it){
      return it != null ? it : 'choose';
    }(
    find(function(it){
      return url.indexOf("/" + it) > -1;
    })(
    Object.keys(
    config)));
    item = config[page];
    store.current.page = 'loading';
    return transaction(function(){
      return restoreItem(url, item, store, function(err){
        var ref$;
        if (err != null) {
          return errorPage(err, store);
        }
        window.document.title = (ref$ = typeof item.title == 'function' ? item.title(store) : void 8) != null
          ? ref$
          : capitalize(page);
        store.current.page = page;
        updateRouter(store);
      });
    });
  };
  out$.reload = reload = function(store){
    return goto(location.pathname, store);
  };
  out$.onHrefClick = onHrefClick = curry$(function(store, event){
    var url;
    event.preventDefault();
    url = event.target.closest('a').href.replace(location.origin, "");
    return goto(url, store);
  });
  out$.restoreRouter = restoreRouter = function(store){
    var url;
    url = location.pathname;
    return goto(url, store);
  };
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
